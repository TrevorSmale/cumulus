<!DOCTYPE html>
<html><head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link rel="alternate" type="application/rss+xml" href="https://github.com/trevorsmale/cumulus/GO/index.xml" title="TS Tech Notes" />
    <link rel="canonical" href="https://github.com/trevorsmale/cumulus/GO/">

    <title>
        
        GO | TS Tech Notes
        
    </title>

    
    <link href="https://github.com/trevorsmale/cumuluscss/fontawesome.min.css" rel="stylesheet">

    
    <link rel="stylesheet" href="https://github.com/trevorsmale/cumulus/css/ace.min.css">

    

    
    
        
    

</head>
<body><nav class="navbar navbar-expand-lg navbar-dark bg-primary shadow sticky-top" id="navbarMain">
    <div class="container">
        <div>
            <a class="navbar-brand" href="/trevorsmale/cumulus">
                
                TS Tech Notes
            </a>
        </div>
        
    </div>
    <div class="feed-icons">
            <a href="https://github.com/trevorsmale/cumulus/GO/index.xml"><img src="/img/feed-icon.svg" alt="RSS feed" /></a>
        </div>
    </nav>
<div class="container-fluid">
            <div class="row">

                <div class="docs-sidenav order-0 col-12 col-md-3 col-lg-2 col-xl-2 position-sticky border-right"><nav class="navbar navbar-expand-md navbar-light pl-0">
    <button class="navbar-toggler navbar-toggler-right collapsed" type="button" data-toggle="collapse" data-target="#sidenav-left-collapse" aria-controls="sidenav-left-collapse" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

     <div class="collapse navbar-collapse align-items-start flex-column" id="sidenav-left-collapse">
            <form class="form-inline my-2 my-lg-0 searchbox">
                <input class="form-control mr-sm-2 w-100" data-search-input id="search-by" type="text" placeholder="Search">
            </form>

        

         <ul class="navbar-nav flex-column pt-3">
    <li data-nav-id="/trevorsmale/cumulus/Workflows/" class="nav-item my-1 haschildren
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Workflows/"><h6>Work-Flows</h6></a>
        
        <ul class="list-unstyled ml-2">
        <li data-nav-id="/trevorsmale/cumulus/Workflows/MSDHNGINX/" class="nav-item my-1">
                
                
                  <a href="/trevorsmale/cumulus/Workflows/MSDHNGINX/" class="nav-link p-0">
                    Multi-Site Single Server
                  </a>
                
        </li>
        <li data-nav-id="/trevorsmale/cumulus/Workflows/Gitea/" class="nav-item my-1">
                
                
                  <a href="/trevorsmale/cumulus/Workflows/Gitea/" class="nav-link p-0">
                    Private Gitea Server
                  </a>
                
        </li>
        <li data-nav-id="/trevorsmale/cumulus/Workflows/RSS/" class="nav-item my-1">
                
                
                  <a href="/trevorsmale/cumulus/Workflows/RSS/" class="nav-link p-0">
                    RSS feed
                  </a>
                
        </li>
        </ul>
    </li>
    <li data-nav-id="/trevorsmale/cumulus/WSL2/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/WSL2/"><h6>WSL2</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/AI/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/AI/"><h6>AI</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/Azure/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Azure/"><h6>Azure</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/Blender-3D/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Blender-3D/"><h6>Blender 3D</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/Containers/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Containers/"><h6>Containers</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/GO/" class="nav-item my-1 parent active haschildren
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/GO/"><h6>GO</h6></a>
        
        <ul class="list-unstyled ml-2">
        <li data-nav-id="/trevorsmale/cumulus/GO/Course1/" class="nav-item my-1">
                
                
                  <a href="/trevorsmale/cumulus/GO/Course1/" class="nav-link p-0">
                    Making Modern Webpages with GO
                  </a>
                
        </li>
        <li data-nav-id="/trevorsmale/cumulus/GO/WAILS/" class="nav-item my-1">
                
                
                  <a href="/trevorsmale/cumulus/GO/WAILS/" class="nav-link p-0">
                    WAILS
                  </a>
                
        </li>
        </ul>
    </li>
    <li data-nav-id="/trevorsmale/cumulus/Linux/" class="nav-item my-1 haschildren
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Linux/"><h6>Linux</h6></a>
        
        <ul class="list-unstyled ml-2">
    <li data-nav-id="/trevorsmale/cumulus/Linux/LPI/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Linux/LPI/"><h6>LPI</h6></a>
        
    </li>
    <li data-nav-id="/trevorsmale/cumulus/Linux/NIX/" class="nav-item my-1
        ">
        
        
          <a class="nav-link p-0" href="/trevorsmale/cumulus/Linux/NIX/"><h6>NIX</h6></a>
        
    </li>
        </ul>
    </li>
        </ul>
    </div>
</nav>


</div>
                <div class="docs-toc large order-lg-2 order-md-0 order-xs-1 col-12 col-lg-2 col-xl-2 position-sticky border-left"><div class="docs-toc">
	<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#go-api">GO API</a></li>
        <li><a href="#go-packaging-modules">Go Packaging Modules</a></li>
        <li><a href="#routers">Routers</a></li>
        <li><a href="#binaries">Binaries</a></li>
        <li><a href="#crud-create-read-update-delete">CRUD Create Read Update Delete</a></li>
        <li><a href="#gorm-object-relational-mapping">GORM Object-Relational Mapping</a></li>
        <li><a href="#retrieving">Retrieving</a></li>
        <li><a href="#basic-server">Basic Server</a></li>
      </ul>
    </li>
    <li><a href="#json">JSON</a></li>
  </ul>
</nav>
</div>
</div>
                <div class="main col-12 order-1 col-md-9 col-lg-10 col-xl-8 py-3">
                

<div class="d-flex flex-column">
    <h1 class="js-title">GO</h1>
    <div class="d-flex align-items-center">
        
    </div>
</div>

<hr>


<p class="lead">
    <h2 id="overview">Overview</h2>
<p>Golang, also known as Go, is a statically typed programming language developed by Google. Designed to be efficient, simple, and highly scalable, Go has gained popularity for its clean syntax, robust standard library, and built-in support for concurrent programming. It emphasizes simplicity and readability, making it easy to learn and write code. Go&rsquo;s strong type system helps catch errors at compile-time, ensuring safer and more reliable code. With its excellent performance and low memory footprint, Go is commonly used for developing web applications, network servers, system tools, and other software projects that require efficiency and concurrency.
</p>

<h2 id="go-api">GO API</h2>
<p>To get started we will have to create a very simple server which can handle HTTP requests. To do this we’ll create a new file called main.go. Within this main.go file we’ll want to define 3 distinct functions. A homePage function that will handle all requests to our root URL, a handleRequests function that will match the URL path hit with a defined function and a main function which will kick off our API.</p>
<pre><code>main.go

package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func homePage(w http.ResponseWriter, r *http.Request){
    fmt.Fprintf(w, &quot;Welcome to the HomePage!&quot;)
    fmt.Println(&quot;Endpoint Hit: homePage&quot;)
}

func handleRequests() {
    http.HandleFunc(&quot;/&quot;, homePage)
    log.Fatal(http.ListenAndServe(&quot;:10000&quot;, nil))
}

func main() {
    handleRequests()
}
</code></pre>
<p>If we run this on our machine now, we should see our very simple API start up on port 10000 if it’s not already been taken by another process. If we now navigate to http://localhost:10000/ in our local browser we should see Welcome to the HomePage! print out on our screen. This means we have successfully created the base from which we’ll build our REST API.</p>
<p>Our Articles Structure</p>
<p>We’ll be creating a REST API that allows us to CREATE, READ, UPDATE and DELETE the articles on our website. When we talk about CRUD APIs we are referring to an API that can handle all of these tasks: Creating, Reading, Updating and Deleting.</p>
<p>Before we can get started, we’ll have to define our Article structure. Go has this concept of structs that are perfect for just this scenario. Let’s create an Article struct that features a Title, a Description (desc) and Content like so:</p>
<pre><code>type Article struct {
    Title string `json:&quot;Title&quot;`
    Desc string `json:&quot;desc&quot;`
    Content string `json:&quot;content&quot;`
}

// let's declare a global Articles array
// that we can then populate in our main function
// to simulate a database
var Articles []Article
</code></pre>
<p>Our Struct contains the 3 properties we need to represent all of the articles on our site. In order for this to work, we’ll also have to import the &ldquo;encoding/json&rdquo; package into our list of imports.</p>
<p>Let’s now update our main function so that our Articles variable is populated with some dummy data that we can retrieve and modify later on.</p>
<pre><code>func main() {
    Articles = []Article{
        Article{Title: &quot;Hello&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
        Article{Title: &quot;Hello 2&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
    }
    handleRequests()
}
</code></pre>
<p>Perfect, let’s now move on to creating our /articles endpoint which will return all of the articles that we’ve just defined here.</p>
<h2 id="go-packaging-modules">Go Packaging Modules</h2>
<ol>
<li>
<p>Initialize a new go module</p>
<p>go mod init github.com/trevorsmale/example</p>
</li>
<li>
<p>Create repository, matching name of repo to name of module</p>
</li>
<li>
<p>Create initial go file with module functions</p>
<p>package mylogger</p>
<p>import &ldquo;log&rdquo;</p>
<p>func LogInfo(message string) {
log.Printf(&ldquo;INFO - %v&rdquo;, message)
}</p>
</li>
<li>
<p>Commit to github</p>
</li>
</ol>
<h2 id="routers">Routers</h2>
<p>Now the standard library is adequate at providing everything you need to get your own simple REST API up and running but now that we’ve got the basic concepts down I feel it’s time to introduce third-party router packages. The most notable and highly used is the gorilla/mux router which, as it stands currently has 2,281 stars on Github.</p>
<p>Building our Router</p>
<p>We can update our existing main.go file and swap in a gorilla/mux based HTTP router in place of the standard library one which was present before.</p>
<p>Modify your handleRequests function so that it creates a new router.</p>
<pre><code>main.go

package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;encoding/json&quot;
    &quot;github.com/gorilla/mux&quot;
)

… // Existing code from above
func handleRequests() {
    // creates a new instance of a mux router
    myRouter := mux.NewRouter().StrictSlash(true)
    // replace http.HandleFunc with myRouter.HandleFunc
    myRouter.HandleFunc(&quot;/&quot;, homePage)
    myRouter.HandleFunc(&quot;/all&quot;, returnAllArticles)
    // finally, instead of passing in nil, we want
    // to pass in our newly created router as the second
    // argument
    log.Fatal(http.ListenAndServe(&quot;:10000&quot;, myRouter))
}

func main() {
    fmt.Println(&quot;Rest API v2.0 - Mux Routers&quot;)
    Articles = []Article{
        Article{Title: &quot;Hello&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
        Article{Title: &quot;Hello 2&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
    }
    handleRequests()
}
</code></pre>
<p>When you now run this, you will see no real change to the way our system works. It will still start up on the same port and return the same results depending on what endpoints you hit.</p>
<p>The only real difference is that we now have a gorilla/mux router which will allow us to easily do things such as retrieve path and query parameters later on in this tutorial.</p>
<pre><code>$ go run main.go

Rest API v2.0 - Mux Routers
</code></pre>
<p>Path Variables</p>
<p>So far so good, we’ve created a very simple REST API that returns a homepage and all our Articles. But what happens if we want to just view one article?</p>
<p>Well, thanks to the gorilla mux router we can add variables to our paths and then pick and choose what articles we want to return based on these variables. Create a new route within your handleRequests() function just below our /articles route:</p>
<pre><code>myRouter.HandleFunc(&quot;/article/{id}&quot;, returnSingleArticle)
</code></pre>
<p>Notice that we’ve added {id} to our path. This will represent our id variable that we’ll be able to use when we wish to return only the article that features that exact key. For now, our Article struct doesn’t feature an Id property. Let’s add that now:</p>
<pre><code>type Article struct {
    Id      string `json:&quot;Id&quot;`
    Title   string `json:&quot;Title&quot;`
    Desc    string `json:&quot;desc&quot;`
    Content string `json:&quot;content&quot;`
}
</code></pre>
<p>We can then update our main function to populate our Id values in our Articles array:</p>
<pre><code>func main() {
    Articles = []Article{
        Article{Id: &quot;1&quot;, Title: &quot;Hello&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
        Article{Id: &quot;2&quot;, Title: &quot;Hello 2&quot;, Desc: &quot;Article Description&quot;, Content: &quot;Article Content&quot;},
    }
    handleRequests()
}
</code></pre>
<p>Now that we’ve done that, in our returnSingleArticle function we can obtain this {id} value from our URL and we can return the article that matches this criteria. As we haven’t stored our data anywhere we’ll just be returning the Id that was passed to the browser.</p>
<pre><code>func returnSingleArticle(w http.ResponseWriter, r *http.Request){
    vars := mux.Vars(r)
    key := vars[&quot;id&quot;]

    fmt.Fprintf(w, &quot;Key: &quot; + key)
}
</code></pre>
<p>If we navigate to http://localhost:1000/article/1after we’ve now run this, you should see Key: 1 being printed out within the browser.</p>
<p>Let’s use this key value to return the specific article that matches that key.</p>
<pre><code>func returnSingleArticle(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    key := vars[&quot;id&quot;]

    // Loop over all of our Articles
    // if the article.Id equals the key we pass in
    // return the article encoded as JSON
    for _, article := range Articles {
        if article.Id == key {
            json.NewEncoder(w).Encode(article)
        }
    }
}
</code></pre>
<h2 id="binaries">Binaries</h2>
<p>Why Go Executables are so damn big</p>
<p>Go binaries are standalone
Everything is statically linked
Memory management
Symbol tables
External packages</p>
<p>The size of the Bin can be reduced by removing debug and symbol table data</p>
<p>Downsides</p>
<p>May cause bugs when:
working with reflections
working with servers and HTTP</p>
<p>Packaging</p>
<p>Go projects can be packaged into single executable binaries.
Go is also capable of building other frameworks into the binary.
REACT front end applications can be packaged with GO and a Database to form a full application.
PocketBase is a great example project that combines Svelt + REACT + GO + SQL LIGHT to form a full service package including payment processing.</p>
<p>Be aware of</p>
<p>CG enabled option</p>
<h2 id="crud-create-read-update-delete">CRUD Create Read Update Delete</h2>
<p>A method to transmit changes to a database</p>
<p>Create – Uses the HTTP POST method to add one or more records.
Read – Uses the HTTP GET method to retrieve one or more records * that match certain criteria.
Update – Uses the HTTP PUT or PATCH methods to update a record.
Delete – Uses the HTTP DELETE method to remove one or more records.</p>
<h2 id="gorm-object-relational-mapping">GORM Object-Relational Mapping</h2>
<p>is a fantastic object-relational mapper (ORM) library for Golang that claims to help developers build faster and make fewer errors.</p>
<p>The GORM library is built on top of the Golang database/sql package. That means it only works with relational databases (MySQL, PostgreSQL, SQLite, etc). Like other ORMs, GORM also provides a lot of tools to help developers interact with databases with ease.</p>
<pre><code>package models

import (
    &quot;time&quot;

    &quot;github.com/google/uuid&quot;
)

type Post struct {
    ID        uuid.UUID `gorm:&quot;type:uuid;default:uuid_generate_v4();primary_key&quot; json:&quot;id,omitempty&quot;`
    Title     string    `gorm:&quot;uniqueIndex;not null&quot; json:&quot;title,omitempty&quot;`
    Content   string    `gorm:&quot;not null&quot; json:&quot;content,omitempty&quot;`
    Image     string    `gorm:&quot;not null&quot; json:&quot;image,omitempty&quot;`
    User      uuid.UUID `gorm:&quot;not null&quot; json:&quot;user,omitempty&quot;`
    CreatedAt time.Time `gorm:&quot;not null&quot; json:&quot;created_at,omitempty&quot;`
    UpdatedAt time.Time `gorm:&quot;not null&quot; json:&quot;updated_at,omitempty&quot;`
}

type CreatePostRequest struct {
    Title     string    `json:&quot;title&quot;  binding:&quot;required&quot;`
    Content   string    `json:&quot;content&quot; binding:&quot;required&quot;`
    Image     string    `json:&quot;image&quot; binding:&quot;required&quot;`
    User      string    `json:&quot;user,omitempty&quot;`
    CreatedAt time.Time `json:&quot;created_at,omitempty&quot;`
    UpdatedAt time.Time `json:&quot;updated_at,omitempty&quot;`
}

type UpdatePost struct {
    Title     string    `json:&quot;title,omitempty&quot;`
    Content   string    `json:&quot;content,omitempty&quot;`
    Image     string    `json:&quot;image,omitempty&quot;`
    User      string    `json:&quot;user,omitempty&quot;`
    CreateAt  time.Time `json:&quot;created_at,omitempty&quot;`
    UpdatedAt time.Time `json:&quot;updated_at,omitempty&quot;`
}
</code></pre>
<h2 id="retrieving">Retrieving</h2>
<p>In this part of the tutorial we are going to create a new REST endpoint which, when hit with a HTTP GET request, will return all of the articles for our site.</p>
<p>We’ll first start off by creating a new function called returnAllArticles, which will do the simple task of returning our newly populated Articles variable, encoded in JSON format:</p>
<pre><code>main.go

func returnAllArticles(w http.ResponseWriter, r *http.Request){
    fmt.Println(&quot;Endpoint Hit: returnAllArticles&quot;)
    json.NewEncoder(w).Encode(Articles)
}
</code></pre>
<p>The call to json.NewEncoder(w).Encode(article) does the job of encoding our articles array into a JSON string and then writing as part of our response.</p>
<p>Before this will work, we’ll also need to add a new route to our handleRequests function that will map any calls to http://localhost:10000/articles to our newly defined function.</p>
<pre><code>func handleRequests() {
    http.HandleFunc(&quot;/&quot;, homePage)
    // add our articles route and map it to our 
    // returnAllArticles function like so
    http.HandleFunc(&quot;/articles&quot;, returnAllArticles)
    log.Fatal(http.ListenAndServe(&quot;:10000&quot;, nil))
}
</code></pre>
<p>Now that we’ve done this, run the code by typing go run main.go and then open up http://localhost:10000/articles in your browser and you should see a JSON representation of your list of articles like so:</p>
<pre><code>http://localhost:10000/articles response

[
{
    Title: &quot;Hello&quot;,
    desc: &quot;Article Description&quot;,
    content: &quot;Article Content&quot;
},
{
    Title: &quot;Hello 2&quot;,
    desc: &quot;Article Description&quot;,
    content: &quot;Article Content&quot;
}
];
</code></pre>
<p>We’ve successfully defined our first API endpoint.</p>
<p>In the next part of this series, you are going to update your REST API to use a gorilla/mux router instead of the traditional net/http router.</p>
<p>Swapping the routers will enable you to more easily perform tasks such as parsing any path or query parameters that may reside within an incoming HTTP request which we will need later on.</p>
<h2 id="basic-server">Basic Server</h2>
<p>Use Go version 1.11 or higher.</p>
<p>Create the following files and folders according to the structure below. The file server.go sits at the root of your project, as does the static folder, which contains two HTML files: index.html and form.html.</p>
<pre><code>- server.go
- static/
- - index.html
- - form.html
</code></pre>
<p>Open the server.go file and import the required packages. Use fmt to print useful data to the terminal and log to print fatal errors in case the web server crashes.</p>
<p>The net/http is the most important package. It provides all the functionality for creating an HTTP client or server implementation such as a Golang web server.</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)
</code></pre>
<p>Lastly, let’s add a simple main() function in the server.go file that prints a message to the terminal.</p>
<pre><code>func main() {
    fmt.Printf(&quot;Starting server at port 8080\n&quot;)
}
</code></pre>
<p>To test the setup, start the fictive server with the following command.</p>
<pre><code>go run server.go
</code></pre>
<h1 id="json">JSON</h1>
<p>Importing, Unmarshalling and Interpreting JSON string data</p>
<p>Let’s assume a simple file config.json, having the following content:</p>
<pre><code>{
    &quot;origin&quot;: &quot;golangdocs.com&quot;,
    &quot;user&quot;: &quot;Vijay&quot;,
    &quot;active&quot;: true
}
</code></pre>
<p>Let’s now extract the JSON data from this config.json file.</p>
<pre><code>// main.go
package main

import (
    &quot;encoding/json&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
)

// The data struct for the decoded data
// Notice that all fields must be exportable!
type Data struct {
    Origin string
    User   string
    Active bool
}

func main() {
    // Let's first read the `config.json` file
    content, err := ioutil.ReadFile(&quot;./config.json&quot;)
    if err != nil {
        log.Fatal(&quot;Error when opening file: &quot;, err)
    }

    // Now let's unmarshall the data into `payload`
    var payload Data
    err = json.Unmarshal(content, &amp;payload)
    if err != nil {
        log.Fatal(&quot;Error during Unmarshal(): &quot;, err)
    }

    // Let's print the unmarshalled data!
    log.Printf(&quot;origin: %s\n&quot;, payload.Origin)
    log.Printf(&quot;user: %s\n&quot;, payload.User)
    log.Printf(&quot;status: %t\n&quot;, payload.Active)
}
</code></pre>
<p>You should get the below output, after creating config.json.</p>
<p>Sample Output</p>
<pre><code>2021/02/07 16:53:53 origin: golangdocs.com
2021/02/07 16:53:53 user: Vijay
2021/02/07 16:53:53 status: true
</code></pre>
<p>Seems straightforward, but you must be a bit careful about one thing, if you’re a newcomer to go.</p>
<p>Golang has a concept of “exported” fields in struct datatypes and functions, so this essentially means that these exported fields are the ones which will be visible across different packages. Since the json unmarshal function is external, it can only see exportable fields.</p>
<p>To make a field exportable, just ensure that you capitalize it! That’s why it’s Origin, User and Active, as opposed to origin, user and active.</p>
<p>Reading Unstructured Data from JSON Files</p>
<p>If the contents of our config.json file keep changing regularly, it is practically impossible to keep track of the changes by modifying the struct fields again and again.</p>
<p>To simplify this, we can use the concept of encoding arbitrary data as an interface. We can replicate the JSON structure by visualizing it as a key-value map.</p>
<p>Here, the key will be a string, and the value can be any interface{}.</p>
<p>So we can simply modify the Data struct into a map[string]interface{}!</p>
<pre><code>// main.go
package main

import (
    &quot;encoding/json&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
)

func main() {
    // Let's first read the `config.json` file
    content, err := ioutil.ReadFile(&quot;./config.json&quot;)
    if err != nil {
        log.Fatal(&quot;Error when opening file: &quot;, err)
    }

    // Now let's unmarshall the data into `payload`
    var payload map[string]interface{}
    err = json.Unmarshal(content, &amp;payload)
    if err != nil {
        log.Fatal(&quot;Error during Unmarshal(): &quot;, err)
    }

    // Let's print the unmarshalled data!
    log.Printf(&quot;origin: %s\n&quot;, payload[&quot;origin&quot;])
    log.Printf(&quot;user: %s\n&quot;, payload[&quot;user&quot;])
    log.Printf(&quot;status: %t\n&quot;, payload[&quot;active&quot;])
}
</code></pre>
<p>Notice now that we can store arbitrary data easily, due to the interface{} map!</p>


    


                    
                    <div class="row"><div class="position-relative mx-auto col-lg-9">
                          <div class="bg-primary overflow-hidden p-3 mt-5 shadow">

    <h4 class="text-white text-center">Read more</h4>

    <div class="d-flex justify-content-center"><a class="p-1 mr-3 d-inline-block text-white" href="/trevorsmale/cumulus/Containers/" title="Containers"><i class="fas fa-chevron-left p-1"></i>Containers</a>
        <a class="p-1 ml-3 d-inline-block text-white text-right" href="/trevorsmale/cumulus/GO/Course1/" title="Making Modern Webpages with GO">Making Modern Webpages with GO<i class="fas fa-chevron-right p-1"></i></a>
    </div>
</div>


                        </div></div> 

                </div>

            </div> 

        </div> 
<script src="https://github.com/trevorsmale/cumuluslib/jquery.min.js"></script> 
<script src="https://github.com/trevorsmale/cumuluslib/popper.min.js"></script> 

<script src="https://github.com/trevorsmale/cumulusjs/bootstrap.min.js"></script> 


<script type="text/javascript" src="/trevorsmale/cumulus/plugins/lunr.min.js"></script>
<script type="text/javascript" src="/trevorsmale/cumulus/plugins/auto-complete.js"></script>
<link href="/trevorsmale/cumulus/plugins/auto-complete.css" rel="stylesheet">
<script type="text/javascript">
  
      var baseurl = "https:\/\/github.com\/trevorsmale\/cumulus";
  
</script>
<script type="text/javascript" src="/trevorsmale/cumulus/plugins/search.js"></script>

<script type="text/javascript" src="/trevorsmale/cumulus/plugins/favorites.js"></script>


<script type="text/javascript" src="/trevorsmale/cumulus/plugins/clipboard.js"></script>
<script>
  new ClipboardJS('.btn');
</script>
</body>
</html>
